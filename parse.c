/*
 * parse.c
 * Qiu Chaofan, 2015/12/21
 *
 * The main recursive descent parser of the Mao programming
 * language.
 */

#include <stdlib.h>
#include "infra/qmemory.h"
#include "infra/qstring.h"
#include "syst/error.h"
#include "lex.h"
#include "parse.h"

#define GRT_DCL_ISTYPESTART(x) \
    ((x) == TOKEN_TYPE_INT || (x) == TOKEN_TYPE_DOUBLE || \
    (x) == TOKEN_TYPE_BOOL || (x) == TOKEN_TYPE_STRING)
#define TOK_CURRTYPE (TOK_CURRTOK.type)
#define TOK_CURRTOK  (qmem_iter_getval(*stream_pos, struct token))
#define TOK_ISCONST(x) \
    ((x) == TOKEN_NUMBER_INT || (x) == TOKEN_NUMBER_FLOAT || \
     (x) == TOKEN_TRUE || (x) == TOKEN_FALSE || (x) == TOKEN_LITERAL)

static qtree_t parse_stmt(qmem_iter_t* stream_pos);
static qtree_t parse_dcl(qmem_iter_t* stream_pos);
static qtree_t parse_expr(qmem_iter_t* stream_pos);
static qtree_t parse_blk(qmem_iter_t* stream_pos);
static qtree_t parse_if(qmem_iter_t* stream_pos);
static qtree_t parse_while(qmem_iter_t* stream_pos);
static qtree_t parse_for(qmem_iter_t* stream_pos);
static qtree_t parse_command(qmem_iter_t* stream_pos);
static qtree_t parse_dcllist(qmem_iter_t* stream_pos);
static qtree_t parse_typeword(qmem_iter_t* stream_pos);

/*
 * Special functions for parsing expressions.
 */
static inline qtree_t parse_expr(qmem_iter_t* stream_pos);

/* These functions will be generated by a macro. */
static inline qtree_t parse_orres(qmem_iter_t* stream_pos);
static inline qtree_t parse_andres(qmem_iter_t* stream_pos);
static inline qtree_t parse_ecomp(qmem_iter_t* stream_pos);
static inline qtree_t parse_necomp(qmem_iter_t* stream_pos);
static inline qtree_t parse_term(qmem_iter_t* stream_pos);
static inline qtree_t parse_factor(qmem_iter_t* stream_pos);
static inline qtree_t parse_power(qmem_iter_t* stream_pos);
/* end */

static qtree_t parse_assignment(qmem_iter_t* stream_pos);
static qtree_t parse_single(qmem_iter_t* stream_pos);
static qtree_t parse_arrv(qmem_iter_t* stream_pos);

qmem_t
mao_parse(qmem_t stream)
{
    qmem_iter_t readptr = qmem_iter_new(stream);
    qmem_t res_stmt_trees = qmem_create(qtree_t);
    for (; !qmem_iter_end(readptr); ) {
        qmem_append(res_stmt_trees, parse_stmt(&readptr), qtree_t);
    }
    return res_stmt_trees;
}

static inline qtree_t
grt_create(int type)
{
    qtree_t res = qtree_create(grt_info);
    qtree_data(res, grt_info) = (grt_info) {
        type, NULL
    };
    return res;
}

/*
 * Grammar of GRT_STATEMENT:
 * statement ->
 *     block        SEMICOLON
 *     declaration  SEMICOLON
 *     for-loop     SEMICOLON
 *     while-loop   SEMICOLON
 *     if-statement SEMICOLON
 *     expr         SEMICOLON
 *     command      SEMICOLON
 *     SEMICOLON
 */
static qtree_t
parse_stmt(qmem_iter_t* stream_pos)
{
    qtree_t res;
    switch (TOK_CURRTYPE) {
    case TOKEN_LBRACE:
        res = parse_blk(stream_pos);
        break;
    case TOKEN_TYPE_INT:
    case TOKEN_TYPE_DOUBLE:
    case TOKEN_TYPE_STRING:
    case TOKEN_TYPE_BOOL:
        res = parse_dcl(stream_pos);
        break;
    case TOKEN_LITERAL:
    case TOKEN_TRUE:
    case TOKEN_FALSE:
    case TOKEN_NUMBER_INT:
    case TOKEN_NUMBER_FLOAT:
    case TOKEN_IDENTIFIER:
    case TOKEN_LPAREN:
    case TOKEN_OP_SUB:
    case TOKEN_OP_NOT:
    case TOKEN_OP_ADD:
        res = parse_expr(stream_pos);
        break;
    case TOKEN_FOR:
    case TOKEN_FOREACH:
        res = parse_for(stream_pos);
        break;
    case TOKEN_WHILE:
    case TOKEN_DO:
        res = parse_while(stream_pos);
        break;
    case TOKEN_IF:
        res = parse_if(stream_pos);
        break;
    case TOKEN_USE:
    case TOKEN_UNUSE:
        res = parse_command(stream_pos);
        break;
    case TOKEN_SEMICOLON:
        res = grt_create(GRT_EMPTY);
        break;
    default:
        res = grt_create(GRT_NULL);
        qmem_iter_forward(stream_pos);
    }

    if (!qmem_iter_end(*stream_pos) && TOK_CURRTYPE == TOKEN_SEMICOLON) {
        qmem_iter_forward(stream_pos);
    } else {
        int tree_type = qtree_data(res, grt_info).type;
        if (tree_type != GRT_NULL && tree_type != GRT_FOR &&
            tree_type != GRT_DOWHILE && tree_type != GRT_FOREACH &&
            tree_type != GRT_WHILE && tree_type != GRT_IF && tree_type != GRT_BLOCK) {
            add_err_queue("Missing ';' at end of statement.");
        }
    }
    return res;
}

/*
 * Grammar of GRT_BLOCK:
 * block ->
 *     LBRACE pstatement RBRACE
 *
 * pstatement ->
 *     statement
 *     statement pstatement
 */
static qtree_t
parse_blk(qmem_iter_t* stream_pos)
{
    qtree_t res = grt_create(GRT_BLOCK);
    if (!qmem_iter_end(*stream_pos) && TOK_CURRTYPE != TOKEN_LBRACE) {
        qtree_data(res, grt_info).type = GRT_NULL;
        add_err_queue("Expected '{'.");
        return res;
    }
    qmem_iter_forward(stream_pos);
    while (!qmem_iter_end(*stream_pos) && TOK_CURRTYPE != TOKEN_RBRACE) {
        qtree_add_child(res, parse_stmt(stream_pos));
    }
    if (qmem_iter_end(*stream_pos) || TOK_CURRTYPE != TOKEN_RBRACE) {
        add_err_queue("Missing '}' at end of block.");
    } else {
        qmem_iter_forward(stream_pos);
    }
    return res;
}

/*
 * Grammar of GRT_DECLARATION:
 * declaration ->
 *     typeword dcl-list
 */
static qtree_t
parse_dcl(qmem_iter_t* stream_pos)
{
    qtree_t res = grt_create(GRT_DECLARATION);
    if (!GRT_DCL_ISTYPESTART(TOK_CURRTYPE)) {
        add_err_queue("Expected typeword: one of 'int' 'bool' 'string' 'double'.");
        while (!qmem_iter_end(*stream_pos)) {
            if (GRT_DCL_ISTYPESTART(TOK_CURRTYPE)) {
                qtree_add_child(res, parse_typeword(stream_pos));
                break;
            } else if (TOK_CURRTYPE == TOKEN_IDENTIFIER) {
                qtree_add_child(res, parse_dcllist(stream_pos));
                break;
            } else {
                qmem_iter_forward(stream_pos);
            }
        }
    } else {
        qtree_add_child(res, parse_typeword(stream_pos));
        if (TOK_CURRTYPE != TOKEN_IDENTIFIER) {
            add_err_queue("Expected identifier after typeword.");
            qmem_iter_forward(stream_pos);
        } else {
            qtree_add_child(res, parse_dcllist(stream_pos));
        }
    }
    return res;
}

/*
 * Grammar of GRT_TYPEWORD:
 * typeword ->
 *     INT
 *     DOUBLE
 *     STRING
 *     BOOL
 *     MAP
 *     LIST
 */
static qtree_t
parse_typeword(qmem_iter_t* stream_pos)
{
    qtree_t res = grt_create(GRT_TYPEWORD);
    qtree_add_child_data(res, &TOK_CURRTOK, struct token);
    qmem_iter_forward(stream_pos);
    return res;
}

/*
 * Grammar of GRT_DCLLIST: (Left recursion removed)
 * dcl-list ->
 *     IDENTIFIER dcl-list-rest
 *     IDENTIFIER ASSIGN expr dcl-list-rest
 *
 * dcl-list-rest ->
 *     NULL
 *     COMMA dcl-list
 */
static qtree_t
parse_dcllist(qmem_iter_t *stream_pos)
{
    qtree_t res = grt_create(GRT_DCLLIST);
    do {
        if (TOK_CURRTYPE == TOKEN_COMMA) {
            /* here 'int, a;' is also right */
            /* TODO: problem: when it reaches end */
            qmem_iter_forward(stream_pos);
        }
        if (TOK_CURRTYPE == TOKEN_IDENTIFIER) {
            qtree_add_child_data(res, &TOK_CURRTOK, struct token);
            qmem_iter_forward(stream_pos);
            if (TOK_CURRTYPE == TOKEN_OP_ASSIGN) {
                qmem_iter_forward(stream_pos);
                /* after identifier is expr, so we need to check when executing */
                qtree_add_child(res, parse_expr(stream_pos));
            }
        } else {
            add_err_queue("Expected identifier after typeword.");
        }
    } while (TOK_CURRTYPE == TOKEN_COMMA);
    return res;
}

/*
 * Grammar of GRT_FOR and GRT_FOREACH:
 * for-loop ->
 *     for-head block
 *     foreach-head block
 *
 * for-head ->
 *     FOR expr for-cond-part for-action-part
 *     FOR LBRACKET declaration RBRACKET for-cond-part for-action-part
 *
 * for-cond-part ->
 *     NULL
 *     WHILE expr
 *
 * for-action-part ->
 *     NULL
 *     DO expr
 *
 * foreach-head ->
 *     FOREACH LBRACKET declaration RBRACKET IN expr
 *     FOREACH IDENTIFIER IN expr
 */
static qtree_t
parse_for(qmem_iter_t* stream_pos)
{
    bool loop_isforeach = (TOK_CURRTYPE == TOKEN_FOREACH);
    qtree_t res = grt_create(loop_isforeach ? GRT_FOREACH : GRT_FOR);
    if (!qmem_iter_end(*stream_pos)) {
        qmem_iter_forward(stream_pos);
    }
    /* loop starts with declaration */
    if (!qmem_iter_end(*stream_pos) && TOK_CURRTYPE == TOKEN_LBRACKET) {
        qmem_iter_forward(stream_pos);
        qtree_add_child(res, parse_dcl(stream_pos));
        if (!qmem_iter_end(*stream_pos) && TOK_CURRTYPE == TOKEN_RBRACKET) {
            qmem_iter_forward(stream_pos);
        } else {
            add_err_queue("Declaration in for loop missing ']'.");
        }
    /* no declaration in loop */
    } else {
        /* in foreach loop, scan an identifier */
        if (loop_isforeach) {
            if (!qmem_iter_end(*stream_pos) && TOK_CURRTYPE == TOKEN_IDENTIFIER) {
                qtree_add_child_data(res, &TOK_CURRTOK, struct token);
                qmem_iter_forward(stream_pos);
            } else {
                add_err_queue("Identifier not found in foreach loop.");
            }
        /* in for loop, scan an expr */
        } else {
            qtree_add_child(res, parse_expr(stream_pos));
        }
    }

    if (loop_isforeach) {
        if (!qmem_iter_end(*stream_pos) && TOK_CURRTYPE == TOKEN_IN) {
            qmem_iter_forward(stream_pos);
        } else {
            add_err_queue("Missing 'in' in foreach loop.");
        }
        if (!qmem_iter_end(*stream_pos) && TOK_CURRTYPE == TOKEN_LBRACE) {
            add_err_queue("Missing range in foreach loop.");
        } else {
            qtree_add_child(res, parse_expr(stream_pos));
        }
    } else {
        /* DO and WHILE can change positions */
        qtree_t for_cond_tmp = NULL;
        qtree_t for_action_tmp = NULL;

        int token_tmp = TOK_CURRTYPE;
        /* not a good method */
        while (!qmem_iter_end(*stream_pos) &&
               (token_tmp == TOKEN_DO || token_tmp == TOKEN_WHILE)) {
            if (token_tmp == TOKEN_DO) {
                qmem_iter_forward(stream_pos);
                for_action_tmp = parse_expr(stream_pos);
            } else if (token_tmp == TOKEN_WHILE) {
                qmem_iter_forward(stream_pos);
                for_action_tmp = parse_expr(stream_pos);
            }
            if (!qmem_iter_end(*stream_pos)) {
                token_tmp = TOK_CURRTYPE;
            } else {
                token_tmp = TOKEN_END;
            }
        }
        /* maybe null, is that right? */
        qtree_add_child(res, for_cond_tmp);
        qtree_add_child(res, for_action_tmp);
    }
    qtree_add_child(res, parse_blk(stream_pos));
    return res;
}

/*
 * Grammar of GRT_WHILE and GRT_DOWHILE:
 * while-loop ->
 *     WHILE expr block
 *     DO block WHILE expr
 */
static qtree_t
parse_while(qmem_iter_t *stream_pos)
{
    bool loop_isdo = (TOK_CURRTYPE == TOKEN_DO);
    qtree_t res = grt_create(loop_isdo ? GRT_DOWHILE : GRT_WHILE);
    qtree_t loop_cond_tmp = NULL;
    qtree_t loop_action_tmp = NULL;
    if (loop_isdo) {
        qmem_iter_forward(stream_pos);
        loop_action_tmp = parse_blk(stream_pos);
        if (TOK_CURRTYPE == TOKEN_WHILE) {
            qmem_iter_forward(stream_pos);
        } else {
            add_err_queue("Missing 'while' at end of do-while loop.");
        }
        loop_cond_tmp = parse_expr(stream_pos);
    } else {
        qmem_iter_forward(stream_pos);
        loop_cond_tmp = parse_expr(stream_pos);
        loop_action_tmp = parse_blk(stream_pos);
    }
    /*
     * Whether the real source code is while or do-while, in the grammar tree,
     * both will be represented in 'cond comes before action'. In do-while
     * loop, even if the cond is false at start, the block will be executed once.
     * In the executing process, the program will make judgement only by the type
     * is GRT_WHILE or GRT_DOWHILE.
     */
    qtree_add_child(res, loop_cond_tmp);
    qtree_add_child(res, loop_action_tmp);
    return res;
}

/*
 * Grammar of GRT_COMMAND:
 * command ->
 *     commandname commandobj
 *
 * Where commandname only supports 'use' and 'unuse' temporarily.
 */
static qtree_t
parse_command(qmem_iter_t *stream_pos)
{
    qtree_t res = grt_create(GRT_COMMAND);
    qtree_add_child_data(res, &TOK_CURRTOK, struct token);
    qmem_iter_forward(stream_pos);
    if (TOK_CURRTYPE != TOKEN_IDENTIFIER) {
        add_err_queue("Expect identifier after 'use' or 'unuse'.");
        qtree_free(res);
        return NULL;
    }
    qtree_add_child_data(res, &TOK_CURRTOK, struct token);
    qmem_iter_forward(stream_pos);
    return res;
}

/*
 * Grammar of GRT_IF:
 * if-statement ->
 *     IF expr block if-rest
 * if-rest
 *     NULL
 *     ELSE block
 *     ELSE IF expr block if-rest
 */
static qtree_t
parse_if(qmem_iter_t *stream_pos)
{
    qtree_t res = grt_create(GRT_IF);
    qmem_iter_forward(stream_pos);
    qtree_add_child(res, parse_expr(stream_pos));
    qtree_add_child(res, parse_blk(stream_pos));
    while (!qmem_iter_end(*stream_pos) && TOK_CURRTYPE == TOKEN_ELSE) {
        qmem_iter_forward(stream_pos);
        if (TOK_CURRTYPE == TOKEN_IF) {
            qmem_iter_forward(stream_pos);
            qtree_add_child(res, parse_expr(stream_pos));
        }
        qtree_add_child(res, parse_blk(stream_pos));
    }
    return res;
}

/*
 * Grammar of GRT_EXPR:
 * expr ->
 *     assignment
 */
inline static qtree_t
parse_expr(qmem_iter_t *stream_pos)
{
    return parse_assignment(stream_pos);
}

/*
 * This array is used for function generation.
 * Operators defined in lex.h shows an special order, by which a function can easily
 * find out what level of expr-grammar by the operator code.
 */
static const int op_grt_relation[] = {
    GRT_EXPR_TERM, GRT_EXPR_TERM,
    GRT_EXPR_FACTOR, GRT_EXPR_FACTOR, GRT_EXPR_FACTOR,
    GRT_EXPR_ASSIGN, GRT_EXPR_ASSIGN, GRT_EXPR_ASSIGN, GRT_EXPR_ASSIGN,
    GRT_EXPR_ASSIGN, GRT_EXPR_ASSIGN, GRT_EXPR_ASSIGN,
    GRT_EXPR_NECOMP, GRT_EXPR_NECOMP, GRT_EXPR_NECOMP, GRT_EXPR_NECOMP,
    GRT_EXPR_ECOMP, GRT_EXPR_ECOMP,
    GRT_EXPR_ANDRES,
    GRT_EXPR_ORRES,
    GRT_EXPR_ARRV
};

/*
 * Grammar of GRT_EXPR_ASSIGN:
 * assignment ->
 *     orres
 *     orres ASSIGN assignment
 */
static qtree_t
parse_assignment(qmem_iter_t *stream_pos)
{
    qtree_t tmp = parse_orres(stream_pos);
    qtree_t res = NULL;
    if (op_grt_relation[TOK_CURRTYPE - TOKEN_OP_ADD] == GRT_EXPR_ASSIGN) {
        res = grt_create(GRT_EXPR_ASSIGN);
        qtree_add_child(res, tmp);
        qtree_add_child_data(res, &TOK_CURRTOK, struct token);
        qmem_iter_forward(stream_pos);
        qtree_add_child(res, parse_assignment(stream_pos));
    } else {
        res = tmp;
    }
    return res;
}

/*
 * Macro generator.
 * From GRT_EXPR_ORRES descending to GRT_EXPR_POWER
 */
#define make_expr_parser(func_suffix, type_suffix, next_suffix)    \
    inline static qtree_t                                          \
    parse_##func_suffix(qmem_iter_t *stream_pos)                   \
    {                                                              \
        qtree_t tmp = parse_##next_suffix(stream_pos);             \
        qtree_t res = NULL;                                        \
        if (op_grt_relation[TOK_CURRTYPE                           \
                - TOKEN_OP_ADD] == GRT_EXPR_##type_suffix) {       \
            res = grt_create(GRT_EXPR_##type_suffix);              \
            qtree_add_child(res, tmp);                             \
            qtree_add_child_data(res,                              \
                    &TOK_CURRTOK, struct token);                   \
            qmem_iter_forward(stream_pos);                         \
            qtree_add_child(res, parse_##next_suffix(stream_pos)); \
        } else {                                                   \
            res = tmp;                                             \
        }                                                          \
        return res;                                                \
    }

make_expr_parser(orres, ORRES, andres)
make_expr_parser(andres, ANDRES,ecomp)
make_expr_parser(ecomp, ECOMP, necomp)
make_expr_parser(necomp, NECOMP, term)
make_expr_parser(term, TERM, factor)
make_expr_parser(factor, FACTOR, power)
make_expr_parser(power, POWER, single)

#undef make_expr_parser

/*
 * Grammar of GRT_EXPR_SINGLE:
 * single ->
 *     arrv
 *     NOT single
 *     SUB single
 *     ADD single
 */
static qtree_t
parse_single(qmem_iter_t *stream_pos)
{
    qtree_t res        = NULL;
    int count        = 0;
    while (TOK_CURRTYPE == TOKEN_OP_SUB || TOK_CURRTYPE == TOKEN_OP_ADD ||
           TOK_CURRTYPE == TOKEN_OP_NOT) {
        if (count++ == 0) {
            res = grt_create(GRT_EXPR_SINGLE);
        }
        qtree_add_child_data(res, &TOK_CURRTOK, struct token);
        qmem_iter_forward(stream_pos);
    }
    if (count == 0) {
        res = parse_arrv(stream_pos);
    } else {
        qtree_add_child(res, parse_arrv(stream_pos));
    }
    return res;
}

/*
 * Grammar of GRT_EXPR_ARRV: (Left recursion removed)
 * arrv ->
 *     r-value arrv-rest
 *     IDENTIFIER arrv-rest
 *     LPAREN expr RPAREN arrv-rest
 *
 * arrv-rest ->
 *     NULL
 *     LBRACKET expr RBRACKET arrv-rest
 */
static qtree_t
parse_arrv(qmem_iter_t *stream_pos)
{
    qtree_t res = grt_create(GRT_EXPR_ARRV);
    if (TOK_CURRTYPE == TOKEN_LPAREN) {
        qmem_iter_forward(stream_pos);
        qtree_add_child(res, parse_expr(stream_pos));
        if (TOK_CURRTYPE == TOKEN_RPAREN) {
            qmem_iter_forward(stream_pos);
        } else {
            add_err_queue("No matching ')' for '('.");
        }
    } else {
        if (TOK_CURRTYPE == TOKEN_IDENTIFIER || TOK_ISCONST(TOK_CURRTYPE)) {
            qtree_add_child_data(res, &TOK_CURRTOK, struct token);
            qmem_iter_forward(stream_pos);
        }
        while (TOK_CURRTYPE == TOKEN_LBRACKET) {
            qtree_add_child_data(res, &TOK_CURRTOK, struct token);
            qmem_iter_forward(stream_pos);
            qtree_add_child(res, parse_expr(stream_pos));
            if (TOK_CURRTYPE == TOKEN_RBRACKET) {
                qmem_iter_forward(stream_pos);
            } else {
                add_err_queue("No matching ']' for '['.");
            }
        }
    }
    return res;
}

